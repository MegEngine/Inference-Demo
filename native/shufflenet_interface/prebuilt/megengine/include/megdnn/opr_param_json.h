// generated by gen_param_defs.py for 3ee22bd53ea17a1bc58e7b12d5bea747583fa311cd23cab1a3a07733cf74642f
// this file can only be included in megbrain/src/plugin/impl/opr_footprint.cpp
// please do not include it directly
#include "megdnn/opr_param_defs.h"
#pragma once
using namespace megdnn;
namespace mgb {
namespace opr {
template<class OprParam>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const OprParam &param);
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::Empty &p) {
    return json::Object::make({
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::Axis &p) {
    return json::Object::make({
        {"axis", json::NumberInt::make(static_cast<int64_t>(p.axis))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::ConvolutionV0 &p) {
    auto Mode2str = [](const param::ConvolutionV0::Mode arg) -> std::string {
        switch (arg) {
            case param::ConvolutionV0::Mode::CROSS_CORRELATION: return "CROSS_CORRELATION";
            case param::ConvolutionV0::Mode::CONVOLUTION: return "CONVOLUTION";
            default: mgb_throw(MegBrainError, "Invalid param::ConvolutionV0::Mode:%d", static_cast<int>(arg));
        }
    };
    auto DataType2str = [](const param::ConvolutionV0::DataType arg) -> std::string {
        switch (arg) {
            case param::ConvolutionV0::DataType::FLOAT: return "FLOAT";
            case param::ConvolutionV0::DataType::INT8x8x16: return "INT8x8x16";
            case param::ConvolutionV0::DataType::INT8x8x32: return "INT8x8x32";
            case param::ConvolutionV0::DataType::FLOAT_IO16xC32: return "FLOAT_IO16xC32";
            case param::ConvolutionV0::DataType::QUINT8x8x32: return "QUINT8x8x32";
            case param::ConvolutionV0::DataType::INT8x8xX: return "INT8x8xX";
            case param::ConvolutionV0::DataType::QUINT4x4x32: return "QUINT4x4x32";
            default: mgb_throw(MegBrainError, "Invalid param::ConvolutionV0::DataType:%d", static_cast<int>(arg));
        }
    };
    auto Sparse2str = [](const param::ConvolutionV0::Sparse arg) -> std::string {
        switch (arg) {
            case param::ConvolutionV0::Sparse::DENSE: return "DENSE";
            case param::ConvolutionV0::Sparse::GROUP: return "GROUP";
            default: mgb_throw(MegBrainError, "Invalid param::ConvolutionV0::Sparse:%d", static_cast<int>(arg));
        }
    };
    auto Format2str = [](const param::ConvolutionV0::Format arg) -> std::string {
        switch (arg) {
            case param::ConvolutionV0::Format::NCHW: return "NCHW";
            case param::ConvolutionV0::Format::NHWC: return "NHWC";
            case param::ConvolutionV0::Format::NHWCD4: return "NHWCD4";
            case param::ConvolutionV0::Format::NCHW4: return "NCHW4";
            case param::ConvolutionV0::Format::NCHW8: return "NCHW8";
            case param::ConvolutionV0::Format::NCHW32: return "NCHW32";
            case param::ConvolutionV0::Format::NCHW88: return "NCHW88";
            case param::ConvolutionV0::Format::NCHW44: return "NCHW44";
            case param::ConvolutionV0::Format::NCHW44_DOT: return "NCHW44_DOT";
            case param::ConvolutionV0::Format::NCHW_WINOGRAD: return "NCHW_WINOGRAD";
            case param::ConvolutionV0::Format::NCHW88_WINOGRAD: return "NCHW88_WINOGRAD";
            case param::ConvolutionV0::Format::NCHW44_WINOGRAD: return "NCHW44_WINOGRAD";
            case param::ConvolutionV0::Format::CHWN4: return "CHWN4";
            default: mgb_throw(MegBrainError, "Invalid param::ConvolutionV0::Format:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"mode", json::String::make(Mode2str(p.mode))},
        {"pad_h", json::NumberInt::make(static_cast<int64_t>(p.pad_h))},
        {"pad_w", json::NumberInt::make(static_cast<int64_t>(p.pad_w))},
        {"stride_h", json::NumberInt::make(static_cast<int64_t>(p.stride_h))},
        {"stride_w", json::NumberInt::make(static_cast<int64_t>(p.stride_w))},
        {"dilate_h", json::NumberInt::make(static_cast<int64_t>(p.dilate_h))},
        {"dilate_w", json::NumberInt::make(static_cast<int64_t>(p.dilate_w))},
        {"data_type", json::String::make(DataType2str(p.data_type))},
        {"sparse", json::String::make(Sparse2str(p.sparse))},
        {"format", json::String::make(Format2str(p.format))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::Convolution &p) {
    auto Mode2str = [](const param::Convolution::Mode arg) -> std::string {
        switch (arg) {
            case param::Convolution::Mode::CROSS_CORRELATION: return "CROSS_CORRELATION";
            case param::Convolution::Mode::CONVOLUTION: return "CONVOLUTION";
            default: mgb_throw(MegBrainError, "Invalid param::Convolution::Mode:%d", static_cast<int>(arg));
        }
    };
    auto Sparse2str = [](const param::Convolution::Sparse arg) -> std::string {
        switch (arg) {
            case param::Convolution::Sparse::DENSE: return "DENSE";
            case param::Convolution::Sparse::GROUP: return "GROUP";
            default: mgb_throw(MegBrainError, "Invalid param::Convolution::Sparse:%d", static_cast<int>(arg));
        }
    };
    auto Format2str = [](const param::Convolution::Format arg) -> std::string {
        switch (arg) {
            case param::Convolution::Format::NCHW: return "NCHW";
            case param::Convolution::Format::NHWC: return "NHWC";
            case param::Convolution::Format::NHWCD4: return "NHWCD4";
            case param::Convolution::Format::NCHW4: return "NCHW4";
            case param::Convolution::Format::NCHW8: return "NCHW8";
            case param::Convolution::Format::NCHW32: return "NCHW32";
            case param::Convolution::Format::NCHW88: return "NCHW88";
            case param::Convolution::Format::NCHW44: return "NCHW44";
            case param::Convolution::Format::NCHW44_DOT: return "NCHW44_DOT";
            case param::Convolution::Format::NCHW_WINOGRAD: return "NCHW_WINOGRAD";
            case param::Convolution::Format::NCHW88_WINOGRAD: return "NCHW88_WINOGRAD";
            case param::Convolution::Format::NCHW44_WINOGRAD: return "NCHW44_WINOGRAD";
            case param::Convolution::Format::CHWN4: return "CHWN4";
            default: mgb_throw(MegBrainError, "Invalid param::Convolution::Format:%d", static_cast<int>(arg));
        }
    };
    auto ComputeMode2str = [](const param::Convolution::ComputeMode arg) -> std::string {
        switch (arg) {
            case param::Convolution::ComputeMode::DEFAULT: return "DEFAULT";
            case param::Convolution::ComputeMode::FLOAT32: return "FLOAT32";
            default: mgb_throw(MegBrainError, "Invalid param::Convolution::ComputeMode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"mode", json::String::make(Mode2str(p.mode))},
        {"pad_h", json::NumberInt::make(static_cast<int64_t>(p.pad_h))},
        {"pad_w", json::NumberInt::make(static_cast<int64_t>(p.pad_w))},
        {"stride_h", json::NumberInt::make(static_cast<int64_t>(p.stride_h))},
        {"stride_w", json::NumberInt::make(static_cast<int64_t>(p.stride_w))},
        {"dilate_h", json::NumberInt::make(static_cast<int64_t>(p.dilate_h))},
        {"dilate_w", json::NumberInt::make(static_cast<int64_t>(p.dilate_w))},
        {"sparse", json::String::make(Sparse2str(p.sparse))},
        {"format", json::String::make(Format2str(p.format))},
        {"compute_mode", json::String::make(ComputeMode2str(p.compute_mode))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::MaskPropagate &p) {
    return json::Object::make({
        {"pad_h", json::NumberInt::make(static_cast<int64_t>(p.pad_h))},
        {"pad_w", json::NumberInt::make(static_cast<int64_t>(p.pad_w))},
        {"stride_h", json::NumberInt::make(static_cast<int64_t>(p.stride_h))},
        {"stride_w", json::NumberInt::make(static_cast<int64_t>(p.stride_w))},
        {"kernel_h", json::NumberInt::make(static_cast<int64_t>(p.kernel_h))},
        {"kernel_w", json::NumberInt::make(static_cast<int64_t>(p.kernel_w))},
        {"dilate_h", json::NumberInt::make(static_cast<int64_t>(p.dilate_h))},
        {"dilate_w", json::NumberInt::make(static_cast<int64_t>(p.dilate_w))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::ConvPooling &p) {
    auto Method2str = [](const param::ConvPooling::Method arg) -> std::string {
        switch (arg) {
            case param::ConvPooling::Method::WITH_TEXTURE_OBJ: return "WITH_TEXTURE_OBJ";
            case param::ConvPooling::Method::WITH_SHARED_MEM: return "WITH_SHARED_MEM";
            default: mgb_throw(MegBrainError, "Invalid param::ConvPooling::Method:%d", static_cast<int>(arg));
        }
    };
    auto ConvMode2str = [](const param::ConvPooling::ConvMode arg) -> std::string {
        switch (arg) {
            case param::ConvPooling::ConvMode::CROSS_CORRELATION: return "CROSS_CORRELATION";
            case param::ConvPooling::ConvMode::CONVOLUTION: return "CONVOLUTION";
            default: mgb_throw(MegBrainError, "Invalid param::ConvPooling::ConvMode:%d", static_cast<int>(arg));
        }
    };
    auto PoolMode2str = [](const param::ConvPooling::PoolMode arg) -> std::string {
        switch (arg) {
            case param::ConvPooling::PoolMode::AVERAGE: return "AVERAGE";
            case param::ConvPooling::PoolMode::MAX: return "MAX";
            default: mgb_throw(MegBrainError, "Invalid param::ConvPooling::PoolMode:%d", static_cast<int>(arg));
        }
    };
    auto NonlineMode2str = [](const param::ConvPooling::NonlineMode arg) -> std::string {
        switch (arg) {
            case param::ConvPooling::NonlineMode::IDENTITY: return "IDENTITY";
            case param::ConvPooling::NonlineMode::RELU: return "RELU";
            case param::ConvPooling::NonlineMode::SIGMOID: return "SIGMOID";
            default: mgb_throw(MegBrainError, "Invalid param::ConvPooling::NonlineMode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"method", json::String::make(Method2str(p.method))},
        {"convMode", json::String::make(ConvMode2str(p.convMode))},
        {"poolMode", json::String::make(PoolMode2str(p.poolMode))},
        {"nonlineMode", json::String::make(NonlineMode2str(p.nonlineMode))},
        {"pool_shape_h", json::NumberInt::make(static_cast<int64_t>(p.pool_shape_h))},
        {"pool_shape_w", json::NumberInt::make(static_cast<int64_t>(p.pool_shape_w))},
        {"pool_stride_h", json::NumberInt::make(static_cast<int64_t>(p.pool_stride_h))},
        {"pool_stride_w", json::NumberInt::make(static_cast<int64_t>(p.pool_stride_w))},
        {"pool_pad_h", json::NumberInt::make(static_cast<int64_t>(p.pool_pad_h))},
        {"pool_pad_w", json::NumberInt::make(static_cast<int64_t>(p.pool_pad_w))},
        {"conv_stride_h", json::NumberInt::make(static_cast<int64_t>(p.conv_stride_h))},
        {"conv_stride_w", json::NumberInt::make(static_cast<int64_t>(p.conv_stride_w))},
        {"conv_pad_h", json::NumberInt::make(static_cast<int64_t>(p.conv_pad_h))},
        {"conv_pad_w", json::NumberInt::make(static_cast<int64_t>(p.conv_pad_w))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::ConvBiasV0 &p) {
    auto NonlineMode2str = [](const param::ConvBiasV0::NonlineMode arg) -> std::string {
        switch (arg) {
            case param::ConvBiasV0::NonlineMode::IDENTITY: return "IDENTITY";
            case param::ConvBiasV0::NonlineMode::RELU: return "RELU";
            case param::ConvBiasV0::NonlineMode::SIGMOID: return "SIGMOID";
            case param::ConvBiasV0::NonlineMode::H_SWISH: return "H_SWISH";
            default: mgb_throw(MegBrainError, "Invalid param::ConvBiasV0::NonlineMode:%d", static_cast<int>(arg));
        }
    };
    auto Mode2str = [](const param::ConvBiasV0::Mode arg) -> std::string {
        switch (arg) {
            case param::ConvBiasV0::Mode::CROSS_CORRELATION: return "CROSS_CORRELATION";
            case param::ConvBiasV0::Mode::CONVOLUTION: return "CONVOLUTION";
            default: mgb_throw(MegBrainError, "Invalid param::ConvBiasV0::Mode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"nonlineMode", json::String::make(NonlineMode2str(p.nonlineMode))},
        {"mode", json::String::make(Mode2str(p.mode))},
        {"pad_h", json::NumberInt::make(static_cast<int64_t>(p.pad_h))},
        {"pad_w", json::NumberInt::make(static_cast<int64_t>(p.pad_w))},
        {"stride_h", json::NumberInt::make(static_cast<int64_t>(p.stride_h))},
        {"stride_w", json::NumberInt::make(static_cast<int64_t>(p.stride_w))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::ConvBiasV1 &p) {
    auto NonlineMode2str = [](const param::ConvBiasV1::NonlineMode arg) -> std::string {
        switch (arg) {
            case param::ConvBiasV1::NonlineMode::IDENTITY: return "IDENTITY";
            case param::ConvBiasV1::NonlineMode::RELU: return "RELU";
            case param::ConvBiasV1::NonlineMode::SIGMOID: return "SIGMOID";
            case param::ConvBiasV1::NonlineMode::H_SWISH: return "H_SWISH";
            default: mgb_throw(MegBrainError, "Invalid param::ConvBiasV1::NonlineMode:%d", static_cast<int>(arg));
        }
    };
    auto Mode2str = [](const param::ConvBiasV1::Mode arg) -> std::string {
        switch (arg) {
            case param::ConvBiasV1::Mode::CROSS_CORRELATION: return "CROSS_CORRELATION";
            case param::ConvBiasV1::Mode::CONVOLUTION: return "CONVOLUTION";
            default: mgb_throw(MegBrainError, "Invalid param::ConvBiasV1::Mode:%d", static_cast<int>(arg));
        }
    };
    auto DataType2str = [](const param::ConvBiasV1::DataType arg) -> std::string {
        switch (arg) {
            case param::ConvBiasV1::DataType::FLOAT: return "FLOAT";
            case param::ConvBiasV1::DataType::INT8x8x16: return "INT8x8x16";
            case param::ConvBiasV1::DataType::INT8x8x32: return "INT8x8x32";
            case param::ConvBiasV1::DataType::FLOAT_IO16xC32: return "FLOAT_IO16xC32";
            case param::ConvBiasV1::DataType::QUINT8x8x32: return "QUINT8x8x32";
            case param::ConvBiasV1::DataType::INT8x8xX: return "INT8x8xX";
            case param::ConvBiasV1::DataType::QUINT4x4x32: return "QUINT4x4x32";
            default: mgb_throw(MegBrainError, "Invalid param::ConvBiasV1::DataType:%d", static_cast<int>(arg));
        }
    };
    auto Sparse2str = [](const param::ConvBiasV1::Sparse arg) -> std::string {
        switch (arg) {
            case param::ConvBiasV1::Sparse::DENSE: return "DENSE";
            case param::ConvBiasV1::Sparse::GROUP: return "GROUP";
            default: mgb_throw(MegBrainError, "Invalid param::ConvBiasV1::Sparse:%d", static_cast<int>(arg));
        }
    };
    auto Format2str = [](const param::ConvBiasV1::Format arg) -> std::string {
        switch (arg) {
            case param::ConvBiasV1::Format::NCHW: return "NCHW";
            case param::ConvBiasV1::Format::NHWC: return "NHWC";
            case param::ConvBiasV1::Format::NHWCD4: return "NHWCD4";
            case param::ConvBiasV1::Format::NCHW4: return "NCHW4";
            case param::ConvBiasV1::Format::NCHW8: return "NCHW8";
            case param::ConvBiasV1::Format::NCHW32: return "NCHW32";
            case param::ConvBiasV1::Format::NCHW88: return "NCHW88";
            case param::ConvBiasV1::Format::NCHW44: return "NCHW44";
            case param::ConvBiasV1::Format::NCHW44_DOT: return "NCHW44_DOT";
            case param::ConvBiasV1::Format::NCHW_WINOGRAD: return "NCHW_WINOGRAD";
            case param::ConvBiasV1::Format::NCHW88_WINOGRAD: return "NCHW88_WINOGRAD";
            case param::ConvBiasV1::Format::NCHW44_WINOGRAD: return "NCHW44_WINOGRAD";
            case param::ConvBiasV1::Format::CHWN4: return "CHWN4";
            default: mgb_throw(MegBrainError, "Invalid param::ConvBiasV1::Format:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"nonlineMode", json::String::make(NonlineMode2str(p.nonlineMode))},
        {"mode", json::String::make(Mode2str(p.mode))},
        {"data_type", json::String::make(DataType2str(p.data_type))},
        {"sparse", json::String::make(Sparse2str(p.sparse))},
        {"format", json::String::make(Format2str(p.format))},
        {"pad_h", json::NumberInt::make(static_cast<int64_t>(p.pad_h))},
        {"pad_w", json::NumberInt::make(static_cast<int64_t>(p.pad_w))},
        {"stride_h", json::NumberInt::make(static_cast<int64_t>(p.stride_h))},
        {"stride_w", json::NumberInt::make(static_cast<int64_t>(p.stride_w))},
        {"dilate_h", json::NumberInt::make(static_cast<int64_t>(p.dilate_h))},
        {"dilate_w", json::NumberInt::make(static_cast<int64_t>(p.dilate_w))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::ConvBiasV2 &p) {
    auto NonlineMode2str = [](const param::ConvBiasV2::NonlineMode arg) -> std::string {
        switch (arg) {
            case param::ConvBiasV2::NonlineMode::IDENTITY: return "IDENTITY";
            case param::ConvBiasV2::NonlineMode::RELU: return "RELU";
            case param::ConvBiasV2::NonlineMode::SIGMOID: return "SIGMOID";
            case param::ConvBiasV2::NonlineMode::H_SWISH: return "H_SWISH";
            default: mgb_throw(MegBrainError, "Invalid param::ConvBiasV2::NonlineMode:%d", static_cast<int>(arg));
        }
    };
    auto Mode2str = [](const param::ConvBiasV2::Mode arg) -> std::string {
        switch (arg) {
            case param::ConvBiasV2::Mode::CROSS_CORRELATION: return "CROSS_CORRELATION";
            case param::ConvBiasV2::Mode::CONVOLUTION: return "CONVOLUTION";
            default: mgb_throw(MegBrainError, "Invalid param::ConvBiasV2::Mode:%d", static_cast<int>(arg));
        }
    };
    auto Sparse2str = [](const param::ConvBiasV2::Sparse arg) -> std::string {
        switch (arg) {
            case param::ConvBiasV2::Sparse::DENSE: return "DENSE";
            case param::ConvBiasV2::Sparse::GROUP: return "GROUP";
            default: mgb_throw(MegBrainError, "Invalid param::ConvBiasV2::Sparse:%d", static_cast<int>(arg));
        }
    };
    auto Format2str = [](const param::ConvBiasV2::Format arg) -> std::string {
        switch (arg) {
            case param::ConvBiasV2::Format::NCHW: return "NCHW";
            case param::ConvBiasV2::Format::NHWC: return "NHWC";
            case param::ConvBiasV2::Format::NHWCD4: return "NHWCD4";
            case param::ConvBiasV2::Format::NCHW4: return "NCHW4";
            case param::ConvBiasV2::Format::NCHW8: return "NCHW8";
            case param::ConvBiasV2::Format::NCHW32: return "NCHW32";
            case param::ConvBiasV2::Format::NCHW88: return "NCHW88";
            case param::ConvBiasV2::Format::NCHW44: return "NCHW44";
            case param::ConvBiasV2::Format::NCHW44_DOT: return "NCHW44_DOT";
            case param::ConvBiasV2::Format::NCHW_WINOGRAD: return "NCHW_WINOGRAD";
            case param::ConvBiasV2::Format::NCHW88_WINOGRAD: return "NCHW88_WINOGRAD";
            case param::ConvBiasV2::Format::NCHW44_WINOGRAD: return "NCHW44_WINOGRAD";
            case param::ConvBiasV2::Format::CHWN4: return "CHWN4";
            default: mgb_throw(MegBrainError, "Invalid param::ConvBiasV2::Format:%d", static_cast<int>(arg));
        }
    };
    auto ComputeMode2str = [](const param::ConvBiasV2::ComputeMode arg) -> std::string {
        switch (arg) {
            case param::ConvBiasV2::ComputeMode::DEFAULT: return "DEFAULT";
            case param::ConvBiasV2::ComputeMode::FLOAT32: return "FLOAT32";
            default: mgb_throw(MegBrainError, "Invalid param::ConvBiasV2::ComputeMode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"nonlineMode", json::String::make(NonlineMode2str(p.nonlineMode))},
        {"mode", json::String::make(Mode2str(p.mode))},
        {"sparse", json::String::make(Sparse2str(p.sparse))},
        {"format", json::String::make(Format2str(p.format))},
        {"pad_h", json::NumberInt::make(static_cast<int64_t>(p.pad_h))},
        {"pad_w", json::NumberInt::make(static_cast<int64_t>(p.pad_w))},
        {"stride_h", json::NumberInt::make(static_cast<int64_t>(p.stride_h))},
        {"stride_w", json::NumberInt::make(static_cast<int64_t>(p.stride_w))},
        {"dilate_h", json::NumberInt::make(static_cast<int64_t>(p.dilate_h))},
        {"dilate_w", json::NumberInt::make(static_cast<int64_t>(p.dilate_w))},
        {"compute_mode", json::String::make(ComputeMode2str(p.compute_mode))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::ConvBias &p) {
    auto NonlineMode2str = [](const param::ConvBias::NonlineMode arg) -> std::string {
        switch (arg) {
            case param::ConvBias::NonlineMode::IDENTITY: return "IDENTITY";
            case param::ConvBias::NonlineMode::RELU: return "RELU";
            case param::ConvBias::NonlineMode::SIGMOID: return "SIGMOID";
            case param::ConvBias::NonlineMode::H_SWISH: return "H_SWISH";
            default: mgb_throw(MegBrainError, "Invalid param::ConvBias::NonlineMode:%d", static_cast<int>(arg));
        }
    };
    auto Mode2str = [](const param::ConvBias::Mode arg) -> std::string {
        switch (arg) {
            case param::ConvBias::Mode::CROSS_CORRELATION: return "CROSS_CORRELATION";
            case param::ConvBias::Mode::CONVOLUTION: return "CONVOLUTION";
            default: mgb_throw(MegBrainError, "Invalid param::ConvBias::Mode:%d", static_cast<int>(arg));
        }
    };
    auto Sparse2str = [](const param::ConvBias::Sparse arg) -> std::string {
        switch (arg) {
            case param::ConvBias::Sparse::DENSE: return "DENSE";
            case param::ConvBias::Sparse::GROUP: return "GROUP";
            default: mgb_throw(MegBrainError, "Invalid param::ConvBias::Sparse:%d", static_cast<int>(arg));
        }
    };
    auto Format2str = [](const param::ConvBias::Format arg) -> std::string {
        switch (arg) {
            case param::ConvBias::Format::NCHW: return "NCHW";
            case param::ConvBias::Format::NHWC: return "NHWC";
            case param::ConvBias::Format::NHWCD4: return "NHWCD4";
            case param::ConvBias::Format::NCHW4: return "NCHW4";
            case param::ConvBias::Format::NCHW8: return "NCHW8";
            case param::ConvBias::Format::NCHW32: return "NCHW32";
            case param::ConvBias::Format::NCHW88: return "NCHW88";
            case param::ConvBias::Format::NCHW44: return "NCHW44";
            case param::ConvBias::Format::NCHW44_DOT: return "NCHW44_DOT";
            case param::ConvBias::Format::NCHW_WINOGRAD: return "NCHW_WINOGRAD";
            case param::ConvBias::Format::NCHW88_WINOGRAD: return "NCHW88_WINOGRAD";
            case param::ConvBias::Format::NCHW44_WINOGRAD: return "NCHW44_WINOGRAD";
            case param::ConvBias::Format::CHWN4: return "CHWN4";
            default: mgb_throw(MegBrainError, "Invalid param::ConvBias::Format:%d", static_cast<int>(arg));
        }
    };
    auto ComputeMode2str = [](const param::ConvBias::ComputeMode arg) -> std::string {
        switch (arg) {
            case param::ConvBias::ComputeMode::DEFAULT: return "DEFAULT";
            case param::ConvBias::ComputeMode::FLOAT32: return "FLOAT32";
            default: mgb_throw(MegBrainError, "Invalid param::ConvBias::ComputeMode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"nonlineMode", json::String::make(NonlineMode2str(p.nonlineMode))},
        {"mode", json::String::make(Mode2str(p.mode))},
        {"sparse", json::String::make(Sparse2str(p.sparse))},
        {"format", json::String::make(Format2str(p.format))},
        {"pad_h", json::NumberInt::make(static_cast<int64_t>(p.pad_h))},
        {"pad_w", json::NumberInt::make(static_cast<int64_t>(p.pad_w))},
        {"stride_h", json::NumberInt::make(static_cast<int64_t>(p.stride_h))},
        {"stride_w", json::NumberInt::make(static_cast<int64_t>(p.stride_w))},
        {"dilate_h", json::NumberInt::make(static_cast<int64_t>(p.dilate_h))},
        {"dilate_w", json::NumberInt::make(static_cast<int64_t>(p.dilate_w))},
        {"output_block_size", json::NumberInt::make(static_cast<int64_t>(p.output_block_size))},
        {"compute_mode", json::String::make(ComputeMode2str(p.compute_mode))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::SeparableConv &p) {
    auto Mode2str = [](const param::SeparableConv::Mode arg) -> std::string {
        switch (arg) {
            case param::SeparableConv::Mode::CROSS_CORRELATION: return "CROSS_CORRELATION";
            case param::SeparableConv::Mode::CONVOLUTION: return "CONVOLUTION";
            default: mgb_throw(MegBrainError, "Invalid param::SeparableConv::Mode:%d", static_cast<int>(arg));
        }
    };
    auto BorderMode2str = [](const param::SeparableConv::BorderMode arg) -> std::string {
        switch (arg) {
            case param::SeparableConv::BorderMode::BORDER_REPLICATE: return "BORDER_REPLICATE";
            case param::SeparableConv::BorderMode::BORDER_REFLECT: return "BORDER_REFLECT";
            case param::SeparableConv::BorderMode::BORDER_REFLECT_101: return "BORDER_REFLECT_101";
            case param::SeparableConv::BorderMode::BORDER_WRAP: return "BORDER_WRAP";
            case param::SeparableConv::BorderMode::BORDER_CONSTANT: return "BORDER_CONSTANT";
            case param::SeparableConv::BorderMode::BORDER_TRANSPARENT: return "BORDER_TRANSPARENT";
            case param::SeparableConv::BorderMode::BORDER_ISOLATED: return "BORDER_ISOLATED";
            default: mgb_throw(MegBrainError, "Invalid param::SeparableConv::BorderMode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"mode", json::String::make(Mode2str(p.mode))},
        {"borderMode", json::String::make(BorderMode2str(p.borderMode))},
        {"is_symm_kernel", json::Bool::make(static_cast<bool>(p.is_symm_kernel))},
        {"pad_h", json::NumberInt::make(static_cast<int64_t>(p.pad_h))},
        {"pad_w", json::NumberInt::make(static_cast<int64_t>(p.pad_w))},
        {"stride_h", json::NumberInt::make(static_cast<int64_t>(p.stride_h))},
        {"stride_w", json::NumberInt::make(static_cast<int64_t>(p.stride_w))},
        {"ksize_h", json::NumberInt::make(static_cast<int64_t>(p.ksize_h))},
        {"ksize_w", json::NumberInt::make(static_cast<int64_t>(p.ksize_w))},
        {"anchor_h", json::NumberInt::make(static_cast<int64_t>(p.anchor_h))},
        {"anchor_w", json::NumberInt::make(static_cast<int64_t>(p.anchor_w))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::Images2Neibs &p) {
    return json::Object::make({
        {"pad_h", json::NumberInt::make(static_cast<int64_t>(p.pad_h))},
        {"pad_w", json::NumberInt::make(static_cast<int64_t>(p.pad_w))},
        {"stride_h", json::NumberInt::make(static_cast<int64_t>(p.stride_h))},
        {"stride_w", json::NumberInt::make(static_cast<int64_t>(p.stride_w))},
        {"window_h", json::NumberInt::make(static_cast<int64_t>(p.window_h))},
        {"window_w", json::NumberInt::make(static_cast<int64_t>(p.window_w))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::Pooling &p) {
    auto Mode2str = [](const param::Pooling::Mode arg) -> std::string {
        switch (arg) {
            case param::Pooling::Mode::MAX: return "MAX";
            case param::Pooling::Mode::AVERAGE: return "AVERAGE";
            case param::Pooling::Mode::AVERAGE_COUNT_EXCLUDE_PADDING: return "AVERAGE_COUNT_EXCLUDE_PADDING";
            default: mgb_throw(MegBrainError, "Invalid param::Pooling::Mode:%d", static_cast<int>(arg));
        }
    };
    auto Format2str = [](const param::Pooling::Format arg) -> std::string {
        switch (arg) {
            case param::Pooling::Format::NCHW: return "NCHW";
            case param::Pooling::Format::NHWC: return "NHWC";
            case param::Pooling::Format::NHWCD4: return "NHWCD4";
            case param::Pooling::Format::NCHW4: return "NCHW4";
            case param::Pooling::Format::NCHW8: return "NCHW8";
            case param::Pooling::Format::NCHW32: return "NCHW32";
            case param::Pooling::Format::NCHW88: return "NCHW88";
            case param::Pooling::Format::NCHW44: return "NCHW44";
            case param::Pooling::Format::NCHW44_DOT: return "NCHW44_DOT";
            case param::Pooling::Format::NCHW_WINOGRAD: return "NCHW_WINOGRAD";
            case param::Pooling::Format::NCHW88_WINOGRAD: return "NCHW88_WINOGRAD";
            case param::Pooling::Format::NCHW44_WINOGRAD: return "NCHW44_WINOGRAD";
            case param::Pooling::Format::CHWN4: return "CHWN4";
            default: mgb_throw(MegBrainError, "Invalid param::Pooling::Format:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"mode", json::String::make(Mode2str(p.mode))},
        {"pad_h", json::NumberInt::make(static_cast<int64_t>(p.pad_h))},
        {"pad_w", json::NumberInt::make(static_cast<int64_t>(p.pad_w))},
        {"stride_h", json::NumberInt::make(static_cast<int64_t>(p.stride_h))},
        {"stride_w", json::NumberInt::make(static_cast<int64_t>(p.stride_w))},
        {"window_h", json::NumberInt::make(static_cast<int64_t>(p.window_h))},
        {"window_w", json::NumberInt::make(static_cast<int64_t>(p.window_w))},
        {"format", json::String::make(Format2str(p.format))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::AdaptivePooling &p) {
    auto Mode2str = [](const param::AdaptivePooling::Mode arg) -> std::string {
        switch (arg) {
            case param::AdaptivePooling::Mode::MAX: return "MAX";
            case param::AdaptivePooling::Mode::AVERAGE: return "AVERAGE";
            case param::AdaptivePooling::Mode::AVERAGE_COUNT_EXCLUDE_PADDING: return "AVERAGE_COUNT_EXCLUDE_PADDING";
            default: mgb_throw(MegBrainError, "Invalid param::AdaptivePooling::Mode:%d", static_cast<int>(arg));
        }
    };
    auto Format2str = [](const param::AdaptivePooling::Format arg) -> std::string {
        switch (arg) {
            case param::AdaptivePooling::Format::NCHW: return "NCHW";
            case param::AdaptivePooling::Format::NHWC: return "NHWC";
            case param::AdaptivePooling::Format::NHWCD4: return "NHWCD4";
            case param::AdaptivePooling::Format::NCHW4: return "NCHW4";
            case param::AdaptivePooling::Format::NCHW8: return "NCHW8";
            case param::AdaptivePooling::Format::NCHW32: return "NCHW32";
            case param::AdaptivePooling::Format::NCHW88: return "NCHW88";
            case param::AdaptivePooling::Format::NCHW44: return "NCHW44";
            case param::AdaptivePooling::Format::NCHW44_DOT: return "NCHW44_DOT";
            case param::AdaptivePooling::Format::NCHW_WINOGRAD: return "NCHW_WINOGRAD";
            case param::AdaptivePooling::Format::NCHW88_WINOGRAD: return "NCHW88_WINOGRAD";
            case param::AdaptivePooling::Format::NCHW44_WINOGRAD: return "NCHW44_WINOGRAD";
            case param::AdaptivePooling::Format::CHWN4: return "CHWN4";
            default: mgb_throw(MegBrainError, "Invalid param::AdaptivePooling::Format:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"mode", json::String::make(Mode2str(p.mode))},
        {"format", json::String::make(Format2str(p.format))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::LRN &p) {
    return json::Object::make({
        {"n", json::NumberInt::make(static_cast<int64_t>(p.n))},
        {"k", json::Number::make(static_cast<double>(p.k))},
        {"alpha", json::Number::make(static_cast<double>(p.alpha))},
        {"beta", json::Number::make(static_cast<double>(p.beta))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::BN &p) {
    auto ParamDim2str = [](const param::BN::ParamDim arg) -> std::string {
        switch (arg) {
            case param::BN::ParamDim::DIM_11HW: return "DIM_11HW";
            case param::BN::ParamDim::DIM_1CHW: return "DIM_1CHW";
            case param::BN::ParamDim::DIM_1C11: return "DIM_1C11";
            default: mgb_throw(MegBrainError, "Invalid param::BN::ParamDim:%d", static_cast<int>(arg));
        }
    };
    auto FwdMode2str = [](const param::BN::FwdMode arg) -> std::string {
        switch (arg) {
            case param::BN::FwdMode::TRAINING: return "TRAINING";
            case param::BN::FwdMode::INFERENCE: return "INFERENCE";
            default: mgb_throw(MegBrainError, "Invalid param::BN::FwdMode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"param_dim", json::String::make(ParamDim2str(p.param_dim))},
        {"fwd_mode", json::String::make(FwdMode2str(p.fwd_mode))},
        {"epsilon", json::Number::make(static_cast<double>(p.epsilon))},
        {"avg_factor", json::Number::make(static_cast<double>(p.avg_factor))},
        {"scale", json::Number::make(static_cast<double>(p.scale))},
        {"bias", json::Number::make(static_cast<double>(p.bias))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::ROIPooling &p) {
    auto Mode2str = [](const param::ROIPooling::Mode arg) -> std::string {
        switch (arg) {
            case param::ROIPooling::Mode::MAX: return "MAX";
            case param::ROIPooling::Mode::AVERAGE: return "AVERAGE";
            default: mgb_throw(MegBrainError, "Invalid param::ROIPooling::Mode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"mode", json::String::make(Mode2str(p.mode))},
        {"scale", json::Number::make(static_cast<double>(p.scale))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::WarpPerspective &p) {
    auto InterpolationMode2str = [](const param::WarpPerspective::InterpolationMode arg) -> std::string {
        switch (arg) {
            case param::WarpPerspective::InterpolationMode::NEAREST: return "NEAREST";
            case param::WarpPerspective::InterpolationMode::LINEAR: return "LINEAR";
            case param::WarpPerspective::InterpolationMode::AREA: return "AREA";
            case param::WarpPerspective::InterpolationMode::CUBIC: return "CUBIC";
            case param::WarpPerspective::InterpolationMode::LANCZOS4: return "LANCZOS4";
            default: mgb_throw(MegBrainError, "Invalid param::WarpPerspective::InterpolationMode:%d", static_cast<int>(arg));
        }
    };
    auto BorderMode2str = [](const param::WarpPerspective::BorderMode arg) -> std::string {
        switch (arg) {
            case param::WarpPerspective::BorderMode::REPLICATE: return "REPLICATE";
            case param::WarpPerspective::BorderMode::REFLECT: return "REFLECT";
            case param::WarpPerspective::BorderMode::REFLECT_101: return "REFLECT_101";
            case param::WarpPerspective::BorderMode::WRAP: return "WRAP";
            case param::WarpPerspective::BorderMode::CONSTANT: return "CONSTANT";
            case param::WarpPerspective::BorderMode::TRANSPARENT: return "TRANSPARENT";
            case param::WarpPerspective::BorderMode::ISOLATED: return "ISOLATED";
            default: mgb_throw(MegBrainError, "Invalid param::WarpPerspective::BorderMode:%d", static_cast<int>(arg));
        }
    };
    auto Format2str = [](const param::WarpPerspective::Format arg) -> std::string {
        switch (arg) {
            case param::WarpPerspective::Format::NCHW: return "NCHW";
            case param::WarpPerspective::Format::NHWC: return "NHWC";
            case param::WarpPerspective::Format::NHWCD4: return "NHWCD4";
            case param::WarpPerspective::Format::NCHW4: return "NCHW4";
            case param::WarpPerspective::Format::NCHW8: return "NCHW8";
            case param::WarpPerspective::Format::NCHW32: return "NCHW32";
            case param::WarpPerspective::Format::NCHW88: return "NCHW88";
            case param::WarpPerspective::Format::NCHW44: return "NCHW44";
            case param::WarpPerspective::Format::NCHW44_DOT: return "NCHW44_DOT";
            case param::WarpPerspective::Format::NCHW_WINOGRAD: return "NCHW_WINOGRAD";
            case param::WarpPerspective::Format::NCHW88_WINOGRAD: return "NCHW88_WINOGRAD";
            case param::WarpPerspective::Format::NCHW44_WINOGRAD: return "NCHW44_WINOGRAD";
            case param::WarpPerspective::Format::CHWN4: return "CHWN4";
            default: mgb_throw(MegBrainError, "Invalid param::WarpPerspective::Format:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"imode", json::String::make(InterpolationMode2str(p.imode))},
        {"bmode", json::String::make(BorderMode2str(p.bmode))},
        {"format", json::String::make(Format2str(p.format))},
        {"border_val", json::Number::make(static_cast<double>(p.border_val))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::SpatialTfGridGenerator &p) {
    auto Mode2str = [](const param::SpatialTfGridGenerator::Mode arg) -> std::string {
        switch (arg) {
            case param::SpatialTfGridGenerator::Mode::AFFINE: return "AFFINE";
            default: mgb_throw(MegBrainError, "Invalid param::SpatialTfGridGenerator::Mode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"mode", json::String::make(Mode2str(p.mode))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::SpatialTfSampler &p) {
    auto Mode2str = [](const param::SpatialTfSampler::Mode arg) -> std::string {
        switch (arg) {
            case param::SpatialTfSampler::Mode::BILINEAR: return "BILINEAR";
            default: mgb_throw(MegBrainError, "Invalid param::SpatialTfSampler::Mode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"mode", json::String::make(Mode2str(p.mode))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::AddUpdate &p) {
    return json::Object::make({
        {"alpha", json::Number::make(static_cast<double>(p.alpha))},
        {"beta", json::Number::make(static_cast<double>(p.beta))},
        {"bias", json::Number::make(static_cast<double>(p.bias))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::Elemwise &p) {
    auto Mode2str = [](const param::Elemwise::Mode arg) -> std::string {
        switch (arg) {
            case param::Elemwise::Mode::RELU: return "RELU";
            case param::Elemwise::Mode::ABS: return "ABS";
            case param::Elemwise::Mode::ACOS: return "ACOS";
            case param::Elemwise::Mode::ASIN: return "ASIN";
            case param::Elemwise::Mode::CEIL: return "CEIL";
            case param::Elemwise::Mode::COS: return "COS";
            case param::Elemwise::Mode::EXP: return "EXP";
            case param::Elemwise::Mode::EXPM1: return "EXPM1";
            case param::Elemwise::Mode::FLOOR: return "FLOOR";
            case param::Elemwise::Mode::LOG: return "LOG";
            case param::Elemwise::Mode::LOG1P: return "LOG1P";
            case param::Elemwise::Mode::NEGATE: return "NEGATE";
            case param::Elemwise::Mode::SIGMOID: return "SIGMOID";
            case param::Elemwise::Mode::SIN: return "SIN";
            case param::Elemwise::Mode::TANH: return "TANH";
            case param::Elemwise::Mode::ABS_GRAD: return "ABS_GRAD";
            case param::Elemwise::Mode::ADD: return "ADD";
            case param::Elemwise::Mode::FLOOR_DIV: return "FLOOR_DIV";
            case param::Elemwise::Mode::MAX: return "MAX";
            case param::Elemwise::Mode::MIN: return "MIN";
            case param::Elemwise::Mode::MOD: return "MOD";
            case param::Elemwise::Mode::MUL: return "MUL";
            case param::Elemwise::Mode::POW: return "POW";
            case param::Elemwise::Mode::SIGMOID_GRAD: return "SIGMOID_GRAD";
            case param::Elemwise::Mode::SUB: return "SUB";
            case param::Elemwise::Mode::SWITCH_GT0: return "SWITCH_GT0";
            case param::Elemwise::Mode::TANH_GRAD: return "TANH_GRAD";
            case param::Elemwise::Mode::TRUE_DIV: return "TRUE_DIV";
            case param::Elemwise::Mode::LOG_SUM_EXP: return "LOG_SUM_EXP";
            case param::Elemwise::Mode::LT: return "LT";
            case param::Elemwise::Mode::LEQ: return "LEQ";
            case param::Elemwise::Mode::EQ: return "EQ";
            case param::Elemwise::Mode::SHL: return "SHL";
            case param::Elemwise::Mode::SHR: return "SHR";
            case param::Elemwise::Mode::COND_LEQ_MOV: return "COND_LEQ_MOV";
            case param::Elemwise::Mode::FUSE_MUL_ADD3: return "FUSE_MUL_ADD3";
            case param::Elemwise::Mode::FUSE_MUL_ADD4: return "FUSE_MUL_ADD4";
            case param::Elemwise::Mode::FUSE_ADD_RELU: return "FUSE_ADD_RELU";
            case param::Elemwise::Mode::FUSE_ADD_SIGMOID: return "FUSE_ADD_SIGMOID";
            case param::Elemwise::Mode::FUSE_ADD_TANH: return "FUSE_ADD_TANH";
            case param::Elemwise::Mode::FAST_TANH: return "FAST_TANH";
            case param::Elemwise::Mode::FAST_TANH_GRAD: return "FAST_TANH_GRAD";
            case param::Elemwise::Mode::ROUND: return "ROUND";
            case param::Elemwise::Mode::RMULH: return "RMULH";
            case param::Elemwise::Mode::ATAN2: return "ATAN2";
            case param::Elemwise::Mode::ERF: return "ERF";
            case param::Elemwise::Mode::ERFINV: return "ERFINV";
            case param::Elemwise::Mode::ERFC: return "ERFC";
            case param::Elemwise::Mode::ERFCINV: return "ERFCINV";
            case param::Elemwise::Mode::H_SWISH: return "H_SWISH";
            case param::Elemwise::Mode::H_SWISH_GRAD: return "H_SWISH_GRAD";
            case param::Elemwise::Mode::FUSE_ADD_H_SWISH: return "FUSE_ADD_H_SWISH";
            case param::Elemwise::Mode::NOT: return "NOT";
            case param::Elemwise::Mode::AND: return "AND";
            case param::Elemwise::Mode::OR: return "OR";
            case param::Elemwise::Mode::XOR: return "XOR";
            default: mgb_throw(MegBrainError, "Invalid param::Elemwise::Mode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"mode", json::String::make(Mode2str(p.mode))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::ElemwiseMultiType &p) {
    auto Mode2str = [](const param::ElemwiseMultiType::Mode arg) -> std::string {
        switch (arg) {
            case param::ElemwiseMultiType::Mode::FUSE_MUL_ADD3_INT16x32x32x32: return "FUSE_MUL_ADD3_INT16x32x32x32";
            case param::ElemwiseMultiType::Mode::FUSE_MUL_ADD3_IXxF32xF32xI8: return "FUSE_MUL_ADD3_IXxF32xF32xI8";
            case param::ElemwiseMultiType::Mode::ROUND_SHR_SATURATE_IXxI8xI8: return "ROUND_SHR_SATURATE_IXxI8xI8";
            case param::ElemwiseMultiType::Mode::FUSE_ADD_RMULH_ROUND_SHR_SATURATE_INT16x16x16x8: return "FUSE_ADD_RMULH_ROUND_SHR_SATURATE_INT16x16x16x8";
            case param::ElemwiseMultiType::Mode::FUSE_ADD_RMULH_ROUND_SHR_SATURATE_INT32x32x32x8: return "FUSE_ADD_RMULH_ROUND_SHR_SATURATE_INT32x32x32x8";
            case param::ElemwiseMultiType::Mode::ROUND_SHR_SATURATE_IXxI8xI16: return "ROUND_SHR_SATURATE_IXxI8xI16";
            case param::ElemwiseMultiType::Mode::QADD: return "QADD";
            case param::ElemwiseMultiType::Mode::QFUSE_ADD_RELU: return "QFUSE_ADD_RELU";
            case param::ElemwiseMultiType::Mode::QMUL: return "QMUL";
            case param::ElemwiseMultiType::Mode::QMIN: return "QMIN";
            case param::ElemwiseMultiType::Mode::QMAX: return "QMAX";
            case param::ElemwiseMultiType::Mode::QSUB: return "QSUB";
            case param::ElemwiseMultiType::Mode::QTRUE_DIV: return "QTRUE_DIV";
            case param::ElemwiseMultiType::Mode::QFUSE_ADD_SIGMOID: return "QFUSE_ADD_SIGMOID";
            case param::ElemwiseMultiType::Mode::QFUSE_ADD_TANH: return "QFUSE_ADD_TANH";
            case param::ElemwiseMultiType::Mode::QRELU: return "QRELU";
            case param::ElemwiseMultiType::Mode::QABS: return "QABS";
            case param::ElemwiseMultiType::Mode::QSIGMOID: return "QSIGMOID";
            case param::ElemwiseMultiType::Mode::QEXP: return "QEXP";
            case param::ElemwiseMultiType::Mode::QTANH: return "QTANH";
            case param::ElemwiseMultiType::Mode::QFUSE_MUL_ADD3: return "QFUSE_MUL_ADD3";
            case param::ElemwiseMultiType::Mode::QFAST_TANH: return "QFAST_TANH";
            case param::ElemwiseMultiType::Mode::QNEGATE: return "QNEGATE";
            case param::ElemwiseMultiType::Mode::QACOS: return "QACOS";
            case param::ElemwiseMultiType::Mode::QASIN: return "QASIN";
            case param::ElemwiseMultiType::Mode::QCEIL: return "QCEIL";
            case param::ElemwiseMultiType::Mode::QCOS: return "QCOS";
            case param::ElemwiseMultiType::Mode::QEXPM1: return "QEXPM1";
            case param::ElemwiseMultiType::Mode::QFLOOR: return "QFLOOR";
            case param::ElemwiseMultiType::Mode::QLOG: return "QLOG";
            case param::ElemwiseMultiType::Mode::QLOG1P: return "QLOG1P";
            case param::ElemwiseMultiType::Mode::QSIN: return "QSIN";
            case param::ElemwiseMultiType::Mode::QROUND: return "QROUND";
            case param::ElemwiseMultiType::Mode::QERF: return "QERF";
            case param::ElemwiseMultiType::Mode::QERFINV: return "QERFINV";
            case param::ElemwiseMultiType::Mode::QERFC: return "QERFC";
            case param::ElemwiseMultiType::Mode::QERFCINV: return "QERFCINV";
            case param::ElemwiseMultiType::Mode::QABS_GRAD: return "QABS_GRAD";
            case param::ElemwiseMultiType::Mode::QFLOOR_DIV: return "QFLOOR_DIV";
            case param::ElemwiseMultiType::Mode::QMOD: return "QMOD";
            case param::ElemwiseMultiType::Mode::QSIGMOID_GRAD: return "QSIGMOID_GRAD";
            case param::ElemwiseMultiType::Mode::QSWITCH_GT0: return "QSWITCH_GT0";
            case param::ElemwiseMultiType::Mode::QTANH_GRAD: return "QTANH_GRAD";
            case param::ElemwiseMultiType::Mode::QLT: return "QLT";
            case param::ElemwiseMultiType::Mode::QLEQ: return "QLEQ";
            case param::ElemwiseMultiType::Mode::QEQ: return "QEQ";
            case param::ElemwiseMultiType::Mode::QPOW: return "QPOW";
            case param::ElemwiseMultiType::Mode::QLOG_SUM_EXP: return "QLOG_SUM_EXP";
            case param::ElemwiseMultiType::Mode::QFAST_TANH_GRAD: return "QFAST_TANH_GRAD";
            case param::ElemwiseMultiType::Mode::QATAN2: return "QATAN2";
            case param::ElemwiseMultiType::Mode::QCOND_LEQ_MOV: return "QCOND_LEQ_MOV";
            case param::ElemwiseMultiType::Mode::QH_SWISH: return "QH_SWISH";
            case param::ElemwiseMultiType::Mode::QFUSE_ADD_H_SWISH: return "QFUSE_ADD_H_SWISH";
            case param::ElemwiseMultiType::Mode::QH_SWISH_GRAD: return "QH_SWISH_GRAD";
            default: mgb_throw(MegBrainError, "Invalid param::ElemwiseMultiType::Mode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"mode", json::String::make(Mode2str(p.mode))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::PowC &p) {
    return json::Object::make({
        {"exp", json::Number::make(static_cast<double>(p.exp))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::MatrixMulV0 &p) {
    auto DataType2str = [](const param::MatrixMulV0::DataType arg) -> std::string {
        switch (arg) {
            case param::MatrixMulV0::DataType::FLOAT: return "FLOAT";
            case param::MatrixMulV0::DataType::INT8x8x16: return "INT8x8x16";
            case param::MatrixMulV0::DataType::INT8x8x32: return "INT8x8x32";
            case param::MatrixMulV0::DataType::FLOAT_IO16xC32: return "FLOAT_IO16xC32";
            case param::MatrixMulV0::DataType::QUINT8x8x32: return "QUINT8x8x32";
            case param::MatrixMulV0::DataType::QUINT4x4x32: return "QUINT4x4x32";
            default: mgb_throw(MegBrainError, "Invalid param::MatrixMulV0::DataType:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"transposeA", json::Bool::make(static_cast<bool>(p.transposeA))},
        {"transposeB", json::Bool::make(static_cast<bool>(p.transposeB))},
        {"data_type", json::String::make(DataType2str(p.data_type))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::MatrixMulV1 &p) {
    auto ComputeMode2str = [](const param::MatrixMulV1::ComputeMode arg) -> std::string {
        switch (arg) {
            case param::MatrixMulV1::ComputeMode::DEFAULT: return "DEFAULT";
            case param::MatrixMulV1::ComputeMode::FLOAT32: return "FLOAT32";
            default: mgb_throw(MegBrainError, "Invalid param::MatrixMulV1::ComputeMode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"transposeA", json::Bool::make(static_cast<bool>(p.transposeA))},
        {"transposeB", json::Bool::make(static_cast<bool>(p.transposeB))},
        {"compute_mode", json::String::make(ComputeMode2str(p.compute_mode))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::MatrixMul &p) {
    auto ComputeMode2str = [](const param::MatrixMul::ComputeMode arg) -> std::string {
        switch (arg) {
            case param::MatrixMul::ComputeMode::DEFAULT: return "DEFAULT";
            case param::MatrixMul::ComputeMode::FLOAT32: return "FLOAT32";
            default: mgb_throw(MegBrainError, "Invalid param::MatrixMul::ComputeMode:%d", static_cast<int>(arg));
        }
    };
    auto Format2str = [](const param::MatrixMul::Format arg) -> std::string {
        switch (arg) {
            case param::MatrixMul::Format::DEFAULT: return "DEFAULT";
            case param::MatrixMul::Format::MK4: return "MK4";
            case param::MatrixMul::Format::MK8: return "MK8";
            case param::MatrixMul::Format::MK4_DOT: return "MK4_DOT";
            default: mgb_throw(MegBrainError, "Invalid param::MatrixMul::Format:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"transposeA", json::Bool::make(static_cast<bool>(p.transposeA))},
        {"transposeB", json::Bool::make(static_cast<bool>(p.transposeB))},
        {"compute_mode", json::String::make(ComputeMode2str(p.compute_mode))},
        {"format", json::String::make(Format2str(p.format))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::Winograd &p) {
    auto Format2str = [](const param::Winograd::Format arg) -> std::string {
        switch (arg) {
            case param::Winograd::Format::DEFAULT: return "DEFAULT";
            case param::Winograd::Format::MK4: return "MK4";
            case param::Winograd::Format::MK8: return "MK8";
            case param::Winograd::Format::MK4_DOT: return "MK4_DOT";
            default: mgb_throw(MegBrainError, "Invalid param::Winograd::Format:%d", static_cast<int>(arg));
        }
    };
    auto ComputeMode2str = [](const param::Winograd::ComputeMode arg) -> std::string {
        switch (arg) {
            case param::Winograd::ComputeMode::DEFAULT: return "DEFAULT";
            case param::Winograd::ComputeMode::FLOAT32: return "FLOAT32";
            default: mgb_throw(MegBrainError, "Invalid param::Winograd::ComputeMode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"output_block_size", json::NumberInt::make(static_cast<int64_t>(p.output_block_size))},
        {"format", json::String::make(Format2str(p.format))},
        {"compute_mode", json::String::make(ComputeMode2str(p.compute_mode))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::SVD &p) {
    return json::Object::make({
        {"full_matrices", json::Bool::make(static_cast<bool>(p.full_matrices))},
        {"compute_uv", json::Bool::make(static_cast<bool>(p.compute_uv))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::ReduceV0 &p) {
    auto Mode2str = [](const param::ReduceV0::Mode arg) -> std::string {
        switch (arg) {
            case param::ReduceV0::Mode::SUM: return "SUM";
            case param::ReduceV0::Mode::SUM_SQR: return "SUM_SQR";
            case param::ReduceV0::Mode::PRODUCT: return "PRODUCT";
            case param::ReduceV0::Mode::MIN: return "MIN";
            case param::ReduceV0::Mode::MAX: return "MAX";
            default: mgb_throw(MegBrainError, "Invalid param::ReduceV0::Mode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"mode", json::String::make(Mode2str(p.mode))},
        {"axis", json::NumberInt::make(static_cast<int64_t>(p.axis))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::ReduceV1 &p) {
    auto Mode2str = [](const param::ReduceV1::Mode arg) -> std::string {
        switch (arg) {
            case param::ReduceV1::Mode::SUM: return "SUM";
            case param::ReduceV1::Mode::SUM_SQR: return "SUM_SQR";
            case param::ReduceV1::Mode::PRODUCT: return "PRODUCT";
            case param::ReduceV1::Mode::MIN: return "MIN";
            case param::ReduceV1::Mode::MAX: return "MAX";
            case param::ReduceV1::Mode::MEAN: return "MEAN";
            default: mgb_throw(MegBrainError, "Invalid param::ReduceV1::Mode:%d", static_cast<int>(arg));
        }
    };
    auto DataType2str = [](const param::ReduceV1::DataType arg) -> std::string {
        switch (arg) {
            case param::ReduceV1::DataType::DEFAULT: return "DEFAULT";
            case param::ReduceV1::DataType::FLOAT_IO16xC32: return "FLOAT_IO16xC32";
            case param::ReduceV1::DataType::FLOAT_O32xC32: return "FLOAT_O32xC32";
            case param::ReduceV1::DataType::FLOAT_O16xC32: return "FLOAT_O16xC32";
            case param::ReduceV1::DataType::QUINT_I8xO32: return "QUINT_I8xO32";
            case param::ReduceV1::DataType::QINT_I8xO32: return "QINT_I8xO32";
            default: mgb_throw(MegBrainError, "Invalid param::ReduceV1::DataType:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"mode", json::String::make(Mode2str(p.mode))},
        {"axis", json::NumberInt::make(static_cast<int64_t>(p.axis))},
        {"data_type", json::String::make(DataType2str(p.data_type))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::Reduce &p) {
    auto Mode2str = [](const param::Reduce::Mode arg) -> std::string {
        switch (arg) {
            case param::Reduce::Mode::SUM: return "SUM";
            case param::Reduce::Mode::SUM_SQR: return "SUM_SQR";
            case param::Reduce::Mode::PRODUCT: return "PRODUCT";
            case param::Reduce::Mode::MIN: return "MIN";
            case param::Reduce::Mode::MAX: return "MAX";
            case param::Reduce::Mode::MEAN: return "MEAN";
            default: mgb_throw(MegBrainError, "Invalid param::Reduce::Mode:%d", static_cast<int>(arg));
        }
    };
    auto DataType2str = [](const param::Reduce::DataType arg) -> std::string {
        switch (arg) {
            case param::Reduce::DataType::DEFAULT: return "DEFAULT";
            case param::Reduce::DataType::FLOAT_IO16xC32: return "FLOAT_IO16xC32";
            case param::Reduce::DataType::FLOAT_O32xC32: return "FLOAT_O32xC32";
            case param::Reduce::DataType::FLOAT_O16xC32: return "FLOAT_O16xC32";
            case param::Reduce::DataType::QUINT_I8xO32: return "QUINT_I8xO32";
            case param::Reduce::DataType::QINT_I8xO32: return "QINT_I8xO32";
            default: mgb_throw(MegBrainError, "Invalid param::Reduce::DataType:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"mode", json::String::make(Mode2str(p.mode))},
        {"axis", json::NumberInt::make(static_cast<int64_t>(p.axis))},
        {"data_type", json::String::make(DataType2str(p.data_type))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::CumsumV0 &p) {
    return json::Object::make({
        {"axis", json::NumberInt::make(static_cast<int64_t>(p.axis))},
        {"exclusive", json::Bool::make(static_cast<bool>(p.exclusive))},
        {"reverse", json::Bool::make(static_cast<bool>(p.reverse))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::Cumsum &p) {
    return json::Object::make({
        {"axis", json::NumberInt::make(static_cast<int64_t>(p.axis))},
        {"exclusive", json::Bool::make(static_cast<bool>(p.exclusive))},
        {"reverse", json::Bool::make(static_cast<bool>(p.reverse))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::CondTake &p) {
    auto Mode2str = [](const param::CondTake::Mode arg) -> std::string {
        switch (arg) {
            case param::CondTake::Mode::EQ: return "EQ";
            case param::CondTake::Mode::NEQ: return "NEQ";
            case param::CondTake::Mode::LT: return "LT";
            case param::CondTake::Mode::LEQ: return "LEQ";
            case param::CondTake::Mode::GT: return "GT";
            case param::CondTake::Mode::GEQ: return "GEQ";
            default: mgb_throw(MegBrainError, "Invalid param::CondTake::Mode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"mode", json::String::make(Mode2str(p.mode))},
        {"val", json::Number::make(static_cast<double>(p.val))},
        {"eps", json::Number::make(static_cast<double>(p.eps))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::Argsort &p) {
    auto Order2str = [](const param::Argsort::Order arg) -> std::string {
        switch (arg) {
            case param::Argsort::Order::ASCENDING: return "ASCENDING";
            case param::Argsort::Order::DESCENDING: return "DESCENDING";
            default: mgb_throw(MegBrainError, "Invalid param::Argsort::Order:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"order", json::String::make(Order2str(p.order))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::IndexingRemap &p) {
    return json::Object::make({
        {"is_non_overlapping", json::Bool::make(static_cast<bool>(p.is_non_overlapping))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::Sleep &p) {
    return json::Object::make({
        {"time", json::Number::make(static_cast<double>(p.time))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::Linspace &p) {
    return json::Object::make({
        {"endpoint", json::Bool::make(static_cast<bool>(p.endpoint))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::LinspaceFull &p) {
    return json::Object::make({
        {"start", json::Number::make(static_cast<double>(p.start))},
        {"stop", json::Number::make(static_cast<double>(p.stop))},
        {"endpoint", json::Bool::make(static_cast<bool>(p.endpoint))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::Eye &p) {
    return json::Object::make({
        {"k", json::NumberInt::make(static_cast<int64_t>(p.k))},
        {"dtype", json::Number::make(static_cast<double>(p.dtype))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::UniformRNG &p) {
    return json::Object::make({
        {"seed", json::NumberInt::make(static_cast<int64_t>(p.seed))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::GaussianRNG &p) {
    return json::Object::make({
        {"seed", json::NumberInt::make(static_cast<int64_t>(p.seed))},
        {"mean", json::Number::make(static_cast<double>(p.mean))},
        {"std", json::Number::make(static_cast<double>(p.std))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::Flip &p) {
    return json::Object::make({
        {"vertical", json::Bool::make(static_cast<bool>(p.vertical))},
        {"horizontal", json::Bool::make(static_cast<bool>(p.horizontal))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::Rotate &p) {
    return json::Object::make({
        {"clockwise", json::Bool::make(static_cast<bool>(p.clockwise))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::ROICopy &p) {
    return json::Object::make({
        {"row_from", json::NumberInt::make(static_cast<int64_t>(p.row_from))},
        {"row_to", json::NumberInt::make(static_cast<int64_t>(p.row_to))},
        {"col_from", json::NumberInt::make(static_cast<int64_t>(p.col_from))},
        {"col_to", json::NumberInt::make(static_cast<int64_t>(p.col_to))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::CvtColor &p) {
    auto Mode2str = [](const param::CvtColor::Mode arg) -> std::string {
        switch (arg) {
            case param::CvtColor::Mode::RGB2GRAY: return "RGB2GRAY";
            case param::CvtColor::Mode::RGB2YUV: return "RGB2YUV";
            case param::CvtColor::Mode::YUV2RGB: return "YUV2RGB";
            case param::CvtColor::Mode::GRAY2RGB: return "GRAY2RGB";
            case param::CvtColor::Mode::RGBA2RGB: return "RGBA2RGB";
            case param::CvtColor::Mode::RGBA2BGR: return "RGBA2BGR";
            case param::CvtColor::Mode::RGBA2GRAY: return "RGBA2GRAY";
            case param::CvtColor::Mode::RGB2BGR: return "RGB2BGR";
            case param::CvtColor::Mode::BGR2GRAY: return "BGR2GRAY";
            case param::CvtColor::Mode::BGR2RGB: return "BGR2RGB";
            case param::CvtColor::Mode::YUV2GRAY_NV21: return "YUV2GRAY_NV21";
            case param::CvtColor::Mode::YUV2RGB_NV21: return "YUV2RGB_NV21";
            case param::CvtColor::Mode::YUV2BGR_NV21: return "YUV2BGR_NV21";
            case param::CvtColor::Mode::YUV2GRAY_NV12: return "YUV2GRAY_NV12";
            case param::CvtColor::Mode::YUV2RGB_NV12: return "YUV2RGB_NV12";
            case param::CvtColor::Mode::YUV2BGR_NV12: return "YUV2BGR_NV12";
            case param::CvtColor::Mode::YUV2GRAY_YV12: return "YUV2GRAY_YV12";
            case param::CvtColor::Mode::YUV2RGB_YV12: return "YUV2RGB_YV12";
            case param::CvtColor::Mode::YUV2BGR_YV12: return "YUV2BGR_YV12";
            case param::CvtColor::Mode::YUV2GRAY_YU12: return "YUV2GRAY_YU12";
            case param::CvtColor::Mode::YUV2RGB_YU12: return "YUV2RGB_YU12";
            case param::CvtColor::Mode::YUV2BGR_YU12: return "YUV2BGR_YU12";
            case param::CvtColor::Mode::YCrCb2RGB: return "YCrCb2RGB";
            case param::CvtColor::Mode::YCrCb2BGR: return "YCrCb2BGR";
            case param::CvtColor::Mode::BT601_YUV2RGB_NV21: return "BT601_YUV2RGB_NV21";
            case param::CvtColor::Mode::BT601_YUV2BGR_NV21: return "BT601_YUV2BGR_NV21";
            case param::CvtColor::Mode::BT601_YUV2RGB_NV12: return "BT601_YUV2RGB_NV12";
            case param::CvtColor::Mode::BT601_YUV2BGR_NV12: return "BT601_YUV2BGR_NV12";
            case param::CvtColor::Mode::BT601_YUV2RGB_YV12: return "BT601_YUV2RGB_YV12";
            case param::CvtColor::Mode::BT601_YUV2BGR_YV12: return "BT601_YUV2BGR_YV12";
            case param::CvtColor::Mode::BT601_YUV2RGB_YU12: return "BT601_YUV2RGB_YU12";
            case param::CvtColor::Mode::BT601_YUV2BGR_YU12: return "BT601_YUV2BGR_YU12";
            default: mgb_throw(MegBrainError, "Invalid param::CvtColor::Mode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"mode", json::String::make(Mode2str(p.mode))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::WarpAffineV0 &p) {
    auto InterpolationMode2str = [](const param::WarpAffineV0::InterpolationMode arg) -> std::string {
        switch (arg) {
            case param::WarpAffineV0::InterpolationMode::NEAREST: return "NEAREST";
            case param::WarpAffineV0::InterpolationMode::LINEAR: return "LINEAR";
            case param::WarpAffineV0::InterpolationMode::AREA: return "AREA";
            case param::WarpAffineV0::InterpolationMode::CUBIC: return "CUBIC";
            case param::WarpAffineV0::InterpolationMode::LANCZOS4: return "LANCZOS4";
            default: mgb_throw(MegBrainError, "Invalid param::WarpAffineV0::InterpolationMode:%d", static_cast<int>(arg));
        }
    };
    auto BorderMode2str = [](const param::WarpAffineV0::BorderMode arg) -> std::string {
        switch (arg) {
            case param::WarpAffineV0::BorderMode::REPLICATE: return "REPLICATE";
            case param::WarpAffineV0::BorderMode::REFLECT: return "REFLECT";
            case param::WarpAffineV0::BorderMode::REFLECT_101: return "REFLECT_101";
            case param::WarpAffineV0::BorderMode::WRAP: return "WRAP";
            case param::WarpAffineV0::BorderMode::CONSTANT: return "CONSTANT";
            case param::WarpAffineV0::BorderMode::TRANSPARENT: return "TRANSPARENT";
            case param::WarpAffineV0::BorderMode::ISOLATED: return "ISOLATED";
            default: mgb_throw(MegBrainError, "Invalid param::WarpAffineV0::BorderMode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"imode", json::String::make(InterpolationMode2str(p.imode))},
        {"border_mode", json::String::make(BorderMode2str(p.border_mode))},
        {"border_val", json::Number::make(static_cast<double>(p.border_val))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::WarpAffine &p) {
    auto InterpolationMode2str = [](const param::WarpAffine::InterpolationMode arg) -> std::string {
        switch (arg) {
            case param::WarpAffine::InterpolationMode::NEAREST: return "NEAREST";
            case param::WarpAffine::InterpolationMode::LINEAR: return "LINEAR";
            case param::WarpAffine::InterpolationMode::AREA: return "AREA";
            case param::WarpAffine::InterpolationMode::CUBIC: return "CUBIC";
            case param::WarpAffine::InterpolationMode::LANCZOS4: return "LANCZOS4";
            default: mgb_throw(MegBrainError, "Invalid param::WarpAffine::InterpolationMode:%d", static_cast<int>(arg));
        }
    };
    auto BorderMode2str = [](const param::WarpAffine::BorderMode arg) -> std::string {
        switch (arg) {
            case param::WarpAffine::BorderMode::REPLICATE: return "REPLICATE";
            case param::WarpAffine::BorderMode::REFLECT: return "REFLECT";
            case param::WarpAffine::BorderMode::REFLECT_101: return "REFLECT_101";
            case param::WarpAffine::BorderMode::WRAP: return "WRAP";
            case param::WarpAffine::BorderMode::CONSTANT: return "CONSTANT";
            case param::WarpAffine::BorderMode::TRANSPARENT: return "TRANSPARENT";
            case param::WarpAffine::BorderMode::ISOLATED: return "ISOLATED";
            default: mgb_throw(MegBrainError, "Invalid param::WarpAffine::BorderMode:%d", static_cast<int>(arg));
        }
    };
    auto Format2str = [](const param::WarpAffine::Format arg) -> std::string {
        switch (arg) {
            case param::WarpAffine::Format::NCHW: return "NCHW";
            case param::WarpAffine::Format::NHWC: return "NHWC";
            case param::WarpAffine::Format::NHWCD4: return "NHWCD4";
            case param::WarpAffine::Format::NCHW4: return "NCHW4";
            case param::WarpAffine::Format::NCHW8: return "NCHW8";
            case param::WarpAffine::Format::NCHW32: return "NCHW32";
            case param::WarpAffine::Format::NCHW88: return "NCHW88";
            case param::WarpAffine::Format::NCHW44: return "NCHW44";
            case param::WarpAffine::Format::NCHW44_DOT: return "NCHW44_DOT";
            case param::WarpAffine::Format::NCHW_WINOGRAD: return "NCHW_WINOGRAD";
            case param::WarpAffine::Format::NCHW88_WINOGRAD: return "NCHW88_WINOGRAD";
            case param::WarpAffine::Format::NCHW44_WINOGRAD: return "NCHW44_WINOGRAD";
            case param::WarpAffine::Format::CHWN4: return "CHWN4";
            default: mgb_throw(MegBrainError, "Invalid param::WarpAffine::Format:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"imode", json::String::make(InterpolationMode2str(p.imode))},
        {"border_mode", json::String::make(BorderMode2str(p.border_mode))},
        {"border_val", json::Number::make(static_cast<double>(p.border_val))},
        {"format", json::String::make(Format2str(p.format))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::GaussianBlur &p) {
    auto BorderMode2str = [](const param::GaussianBlur::BorderMode arg) -> std::string {
        switch (arg) {
            case param::GaussianBlur::BorderMode::REPLICATE: return "REPLICATE";
            case param::GaussianBlur::BorderMode::REFLECT: return "REFLECT";
            case param::GaussianBlur::BorderMode::REFLECT_101: return "REFLECT_101";
            case param::GaussianBlur::BorderMode::WRAP: return "WRAP";
            case param::GaussianBlur::BorderMode::CONSTANT: return "CONSTANT";
            case param::GaussianBlur::BorderMode::TRANSPARENT: return "TRANSPARENT";
            case param::GaussianBlur::BorderMode::ISOLATED: return "ISOLATED";
            default: mgb_throw(MegBrainError, "Invalid param::GaussianBlur::BorderMode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"border_mode", json::String::make(BorderMode2str(p.border_mode))},
        {"kernel_height", json::NumberInt::make(static_cast<int64_t>(p.kernel_height))},
        {"kernel_width", json::NumberInt::make(static_cast<int64_t>(p.kernel_width))},
        {"sigma_x", json::Number::make(static_cast<double>(p.sigma_x))},
        {"sigma_y", json::Number::make(static_cast<double>(p.sigma_y))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::ResizeV0 &p) {
    auto InterpolationMode2str = [](const param::ResizeV0::InterpolationMode arg) -> std::string {
        switch (arg) {
            case param::ResizeV0::InterpolationMode::NEAREST: return "NEAREST";
            case param::ResizeV0::InterpolationMode::LINEAR: return "LINEAR";
            case param::ResizeV0::InterpolationMode::AREA: return "AREA";
            case param::ResizeV0::InterpolationMode::CUBIC: return "CUBIC";
            case param::ResizeV0::InterpolationMode::LANCZOS4: return "LANCZOS4";
            default: mgb_throw(MegBrainError, "Invalid param::ResizeV0::InterpolationMode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"imode", json::String::make(InterpolationMode2str(p.imode))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::Resize &p) {
    auto InterpolationMode2str = [](const param::Resize::InterpolationMode arg) -> std::string {
        switch (arg) {
            case param::Resize::InterpolationMode::NEAREST: return "NEAREST";
            case param::Resize::InterpolationMode::LINEAR: return "LINEAR";
            case param::Resize::InterpolationMode::AREA: return "AREA";
            case param::Resize::InterpolationMode::CUBIC: return "CUBIC";
            case param::Resize::InterpolationMode::LANCZOS4: return "LANCZOS4";
            default: mgb_throw(MegBrainError, "Invalid param::Resize::InterpolationMode:%d", static_cast<int>(arg));
        }
    };
    auto Format2str = [](const param::Resize::Format arg) -> std::string {
        switch (arg) {
            case param::Resize::Format::NCHW: return "NCHW";
            case param::Resize::Format::NHWC: return "NHWC";
            case param::Resize::Format::NHWCD4: return "NHWCD4";
            case param::Resize::Format::NCHW4: return "NCHW4";
            case param::Resize::Format::NCHW8: return "NCHW8";
            case param::Resize::Format::NCHW32: return "NCHW32";
            case param::Resize::Format::NCHW88: return "NCHW88";
            case param::Resize::Format::NCHW44: return "NCHW44";
            case param::Resize::Format::NCHW44_DOT: return "NCHW44_DOT";
            case param::Resize::Format::NCHW_WINOGRAD: return "NCHW_WINOGRAD";
            case param::Resize::Format::NCHW88_WINOGRAD: return "NCHW88_WINOGRAD";
            case param::Resize::Format::NCHW44_WINOGRAD: return "NCHW44_WINOGRAD";
            case param::Resize::Format::CHWN4: return "CHWN4";
            default: mgb_throw(MegBrainError, "Invalid param::Resize::Format:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"imode", json::String::make(InterpolationMode2str(p.imode))},
        {"format", json::String::make(Format2str(p.format))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::Remap &p) {
    auto InterpolationMode2str = [](const param::Remap::InterpolationMode arg) -> std::string {
        switch (arg) {
            case param::Remap::InterpolationMode::NEAREST: return "NEAREST";
            case param::Remap::InterpolationMode::LINEAR: return "LINEAR";
            case param::Remap::InterpolationMode::AREA: return "AREA";
            case param::Remap::InterpolationMode::CUBIC: return "CUBIC";
            case param::Remap::InterpolationMode::LANCZOS4: return "LANCZOS4";
            default: mgb_throw(MegBrainError, "Invalid param::Remap::InterpolationMode:%d", static_cast<int>(arg));
        }
    };
    auto BorderMode2str = [](const param::Remap::BorderMode arg) -> std::string {
        switch (arg) {
            case param::Remap::BorderMode::REPLICATE: return "REPLICATE";
            case param::Remap::BorderMode::REFLECT: return "REFLECT";
            case param::Remap::BorderMode::REFLECT_101: return "REFLECT_101";
            case param::Remap::BorderMode::WRAP: return "WRAP";
            case param::Remap::BorderMode::CONSTANT: return "CONSTANT";
            case param::Remap::BorderMode::TRANSPARENT: return "TRANSPARENT";
            case param::Remap::BorderMode::ISOLATED: return "ISOLATED";
            default: mgb_throw(MegBrainError, "Invalid param::Remap::BorderMode:%d", static_cast<int>(arg));
        }
    };
    auto Format2str = [](const param::Remap::Format arg) -> std::string {
        switch (arg) {
            case param::Remap::Format::NCHW: return "NCHW";
            case param::Remap::Format::NHWC: return "NHWC";
            case param::Remap::Format::NHWCD4: return "NHWCD4";
            case param::Remap::Format::NCHW4: return "NCHW4";
            case param::Remap::Format::NCHW8: return "NCHW8";
            case param::Remap::Format::NCHW32: return "NCHW32";
            case param::Remap::Format::NCHW88: return "NCHW88";
            case param::Remap::Format::NCHW44: return "NCHW44";
            case param::Remap::Format::NCHW44_DOT: return "NCHW44_DOT";
            case param::Remap::Format::NCHW_WINOGRAD: return "NCHW_WINOGRAD";
            case param::Remap::Format::NCHW88_WINOGRAD: return "NCHW88_WINOGRAD";
            case param::Remap::Format::NCHW44_WINOGRAD: return "NCHW44_WINOGRAD";
            case param::Remap::Format::CHWN4: return "CHWN4";
            default: mgb_throw(MegBrainError, "Invalid param::Remap::Format:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"imode", json::String::make(InterpolationMode2str(p.imode))},
        {"border_type", json::String::make(BorderMode2str(p.border_type))},
        {"format", json::String::make(Format2str(p.format))},
        {"scalar", json::Number::make(static_cast<double>(p.scalar))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::Convolution3D &p) {
    auto Mode2str = [](const param::Convolution3D::Mode arg) -> std::string {
        switch (arg) {
            case param::Convolution3D::Mode::CROSS_CORRELATION: return "CROSS_CORRELATION";
            case param::Convolution3D::Mode::CONVOLUTION: return "CONVOLUTION";
            default: mgb_throw(MegBrainError, "Invalid param::Convolution3D::Mode:%d", static_cast<int>(arg));
        }
    };
    auto Sparse2str = [](const param::Convolution3D::Sparse arg) -> std::string {
        switch (arg) {
            case param::Convolution3D::Sparse::DENSE: return "DENSE";
            case param::Convolution3D::Sparse::GROUP: return "GROUP";
            default: mgb_throw(MegBrainError, "Invalid param::Convolution3D::Sparse:%d", static_cast<int>(arg));
        }
    };
    auto DataType2str = [](const param::Convolution3D::DataType arg) -> std::string {
        switch (arg) {
            case param::Convolution3D::DataType::FLOAT: return "FLOAT";
            case param::Convolution3D::DataType::FLOAT_IO16xC32: return "FLOAT_IO16xC32";
            default: mgb_throw(MegBrainError, "Invalid param::Convolution3D::DataType:%d", static_cast<int>(arg));
        }
    };
    auto Format2str = [](const param::Convolution3D::Format arg) -> std::string {
        switch (arg) {
            case param::Convolution3D::Format::NCDHW: return "NCDHW";
            case param::Convolution3D::Format::NDHWC: return "NDHWC";
            default: mgb_throw(MegBrainError, "Invalid param::Convolution3D::Format:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"mode", json::String::make(Mode2str(p.mode))},
        {"pad_d", json::NumberInt::make(static_cast<int64_t>(p.pad_d))},
        {"pad_h", json::NumberInt::make(static_cast<int64_t>(p.pad_h))},
        {"pad_w", json::NumberInt::make(static_cast<int64_t>(p.pad_w))},
        {"stride_d", json::NumberInt::make(static_cast<int64_t>(p.stride_d))},
        {"stride_h", json::NumberInt::make(static_cast<int64_t>(p.stride_h))},
        {"stride_w", json::NumberInt::make(static_cast<int64_t>(p.stride_w))},
        {"dilate_d", json::NumberInt::make(static_cast<int64_t>(p.dilate_d))},
        {"dilate_h", json::NumberInt::make(static_cast<int64_t>(p.dilate_h))},
        {"dilate_w", json::NumberInt::make(static_cast<int64_t>(p.dilate_w))},
        {"sparse", json::String::make(Sparse2str(p.sparse))},
        {"data_type", json::String::make(DataType2str(p.data_type))},
        {"format", json::String::make(Format2str(p.format))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::Conv3DBias &p) {
    auto NonlineMode2str = [](const param::Conv3DBias::NonlineMode arg) -> std::string {
        switch (arg) {
            case param::Conv3DBias::NonlineMode::IDENTITY: return "IDENTITY";
            case param::Conv3DBias::NonlineMode::RELU: return "RELU";
            case param::Conv3DBias::NonlineMode::SIGMOID: return "SIGMOID";
            default: mgb_throw(MegBrainError, "Invalid param::Conv3DBias::NonlineMode:%d", static_cast<int>(arg));
        }
    };
    auto Mode2str = [](const param::Conv3DBias::Mode arg) -> std::string {
        switch (arg) {
            case param::Conv3DBias::Mode::CROSS_CORRELATION: return "CROSS_CORRELATION";
            case param::Conv3DBias::Mode::CONVOLUTION: return "CONVOLUTION";
            default: mgb_throw(MegBrainError, "Invalid param::Conv3DBias::Mode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"nonlineMode", json::String::make(NonlineMode2str(p.nonlineMode))},
        {"mode", json::String::make(Mode2str(p.mode))},
        {"pad_d", json::NumberInt::make(static_cast<int64_t>(p.pad_d))},
        {"pad_h", json::NumberInt::make(static_cast<int64_t>(p.pad_h))},
        {"pad_w", json::NumberInt::make(static_cast<int64_t>(p.pad_w))},
        {"stride_d", json::NumberInt::make(static_cast<int64_t>(p.stride_d))},
        {"stride_h", json::NumberInt::make(static_cast<int64_t>(p.stride_h))},
        {"stride_w", json::NumberInt::make(static_cast<int64_t>(p.stride_w))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::SeparableConv3D &p) {
    auto Mode2str = [](const param::SeparableConv3D::Mode arg) -> std::string {
        switch (arg) {
            case param::SeparableConv3D::Mode::CROSS_CORRELATION: return "CROSS_CORRELATION";
            case param::SeparableConv3D::Mode::CONVOLUTION: return "CONVOLUTION";
            default: mgb_throw(MegBrainError, "Invalid param::SeparableConv3D::Mode:%d", static_cast<int>(arg));
        }
    };
    auto BorderMode2str = [](const param::SeparableConv3D::BorderMode arg) -> std::string {
        switch (arg) {
            case param::SeparableConv3D::BorderMode::BORDER_REPLICATE: return "BORDER_REPLICATE";
            case param::SeparableConv3D::BorderMode::BORDER_REFLECT: return "BORDER_REFLECT";
            case param::SeparableConv3D::BorderMode::BORDER_REFLECT_101: return "BORDER_REFLECT_101";
            case param::SeparableConv3D::BorderMode::BORDER_WRAP: return "BORDER_WRAP";
            case param::SeparableConv3D::BorderMode::BORDER_CONSTANT: return "BORDER_CONSTANT";
            case param::SeparableConv3D::BorderMode::BORDER_TRANSPARENT: return "BORDER_TRANSPARENT";
            case param::SeparableConv3D::BorderMode::BORDER_ISOLATED: return "BORDER_ISOLATED";
            default: mgb_throw(MegBrainError, "Invalid param::SeparableConv3D::BorderMode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"mode", json::String::make(Mode2str(p.mode))},
        {"borderMode", json::String::make(BorderMode2str(p.borderMode))},
        {"is_symm_kernel", json::Bool::make(static_cast<bool>(p.is_symm_kernel))},
        {"pad_d", json::NumberInt::make(static_cast<int64_t>(p.pad_d))},
        {"pad_h", json::NumberInt::make(static_cast<int64_t>(p.pad_h))},
        {"pad_w", json::NumberInt::make(static_cast<int64_t>(p.pad_w))},
        {"stride_d", json::NumberInt::make(static_cast<int64_t>(p.stride_d))},
        {"stride_h", json::NumberInt::make(static_cast<int64_t>(p.stride_h))},
        {"stride_w", json::NumberInt::make(static_cast<int64_t>(p.stride_w))},
        {"ksize_d", json::NumberInt::make(static_cast<int64_t>(p.ksize_d))},
        {"ksize_h", json::NumberInt::make(static_cast<int64_t>(p.ksize_h))},
        {"ksize_w", json::NumberInt::make(static_cast<int64_t>(p.ksize_w))},
        {"anchor_d", json::NumberInt::make(static_cast<int64_t>(p.anchor_d))},
        {"anchor_h", json::NumberInt::make(static_cast<int64_t>(p.anchor_h))},
        {"anchor_w", json::NumberInt::make(static_cast<int64_t>(p.anchor_w))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::TopK &p) {
    auto Mode2str = [](const param::TopK::Mode arg) -> std::string {
        switch (arg) {
            case param::TopK::Mode::KTH_ONLY: return "KTH_ONLY";
            case param::TopK::Mode::VALUE_IDX_NOSORT: return "VALUE_IDX_NOSORT";
            case param::TopK::Mode::VALUE_IDX_SORTED: return "VALUE_IDX_SORTED";
            default: mgb_throw(MegBrainError, "Invalid param::TopK::Mode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"mode", json::String::make(Mode2str(p.mode))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::RelayoutFormat &p) {
    auto Mode2str = [](const param::RelayoutFormat::Mode arg) -> std::string {
        switch (arg) {
            case param::RelayoutFormat::Mode::NHWC_NHWCD4: return "NHWC_NHWCD4";
            case param::RelayoutFormat::Mode::NHWCD4_NHWC: return "NHWCD4_NHWC";
            case param::RelayoutFormat::Mode::NHWC_NHWCD4I: return "NHWC_NHWCD4I";
            case param::RelayoutFormat::Mode::NCHW_NHWCD4: return "NCHW_NHWCD4";
            case param::RelayoutFormat::Mode::NCHW_NHWCD4I: return "NCHW_NHWCD4I";
            case param::RelayoutFormat::Mode::NHWCD4I_NCHW: return "NHWCD4I_NCHW";
            case param::RelayoutFormat::Mode::NHWCD4_NCHW: return "NHWCD4_NCHW";
            case param::RelayoutFormat::Mode::INTER_WEIGHT_DENSE: return "INTER_WEIGHT_DENSE";
            case param::RelayoutFormat::Mode::INTER_WEIGHT_DENSEI: return "INTER_WEIGHT_DENSEI";
            case param::RelayoutFormat::Mode::INTER_WEIGHT_GROUP: return "INTER_WEIGHT_GROUP";
            case param::RelayoutFormat::Mode::INTER_WEIGHT_GROUPI: return "INTER_WEIGHT_GROUPI";
            case param::RelayoutFormat::Mode::INTER_WEIGHT_CHAN: return "INTER_WEIGHT_CHAN";
            case param::RelayoutFormat::Mode::INTER_WEIGHT_CHANI: return "INTER_WEIGHT_CHANI";
            case param::RelayoutFormat::Mode::INTER_WEIGHT_DENSEI_DOT: return "INTER_WEIGHT_DENSEI_DOT";
            case param::RelayoutFormat::Mode::INTER_WEIGHT_GROUPI_DOT: return "INTER_WEIGHT_GROUPI_DOT";
            case param::RelayoutFormat::Mode::NCHW4_CHWN4: return "NCHW4_CHWN4";
            case param::RelayoutFormat::Mode::CHWN4_NCHW4: return "CHWN4_NCHW4";
            case param::RelayoutFormat::Mode::NCHW_NCHW88_CONV_DENSE_WEIGHT: return "NCHW_NCHW88_CONV_DENSE_WEIGHT";
            case param::RelayoutFormat::Mode::NCHW_NCHW88_CONV_CHAN_WEIGHT: return "NCHW_NCHW88_CONV_CHAN_WEIGHT";
            case param::RelayoutFormat::Mode::NCHW_NCHW88_CONV_GROUP_WEIGHT: return "NCHW_NCHW88_CONV_GROUP_WEIGHT";
            case param::RelayoutFormat::Mode::NCHW_NCHW88: return "NCHW_NCHW88";
            case param::RelayoutFormat::Mode::NCHW88_NCHW: return "NCHW88_NCHW";
            case param::RelayoutFormat::Mode::NCHW_NCHW4_IC_SMALL: return "NCHW_NCHW4_IC_SMALL";
            case param::RelayoutFormat::Mode::NCHW_NCHW4_IC_SMALL_CONV_DENSE_WEIGHT: return "NCHW_NCHW4_IC_SMALL_CONV_DENSE_WEIGHT";
            default: mgb_throw(MegBrainError, "Invalid param::RelayoutFormat::Mode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"mode", json::String::make(Mode2str(p.mode))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::SeparableFilter &p) {
    auto Format2str = [](const param::SeparableFilter::Format arg) -> std::string {
        switch (arg) {
            case param::SeparableFilter::Format::NCHW: return "NCHW";
            case param::SeparableFilter::Format::NHWC: return "NHWC";
            case param::SeparableFilter::Format::NHWCD4: return "NHWCD4";
            case param::SeparableFilter::Format::NCHW4: return "NCHW4";
            case param::SeparableFilter::Format::NCHW8: return "NCHW8";
            case param::SeparableFilter::Format::NCHW32: return "NCHW32";
            case param::SeparableFilter::Format::NCHW88: return "NCHW88";
            case param::SeparableFilter::Format::NCHW44: return "NCHW44";
            case param::SeparableFilter::Format::NCHW44_DOT: return "NCHW44_DOT";
            case param::SeparableFilter::Format::NCHW_WINOGRAD: return "NCHW_WINOGRAD";
            case param::SeparableFilter::Format::NCHW88_WINOGRAD: return "NCHW88_WINOGRAD";
            case param::SeparableFilter::Format::NCHW44_WINOGRAD: return "NCHW44_WINOGRAD";
            case param::SeparableFilter::Format::CHWN4: return "CHWN4";
            default: mgb_throw(MegBrainError, "Invalid param::SeparableFilter::Format:%d", static_cast<int>(arg));
        }
    };
    auto BorderMode2str = [](const param::SeparableFilter::BorderMode arg) -> std::string {
        switch (arg) {
            case param::SeparableFilter::BorderMode::REPLICATE: return "REPLICATE";
            case param::SeparableFilter::BorderMode::REFLECT: return "REFLECT";
            case param::SeparableFilter::BorderMode::REFLECT_101: return "REFLECT_101";
            case param::SeparableFilter::BorderMode::WRAP: return "WRAP";
            case param::SeparableFilter::BorderMode::CONSTANT: return "CONSTANT";
            case param::SeparableFilter::BorderMode::TRANSPARENT: return "TRANSPARENT";
            case param::SeparableFilter::BorderMode::ISOLATED: return "ISOLATED";
            default: mgb_throw(MegBrainError, "Invalid param::SeparableFilter::BorderMode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"format", json::String::make(Format2str(p.format))},
        {"borderMode", json::String::make(BorderMode2str(p.borderMode))},
        {"is_symm_kernel", json::Bool::make(static_cast<bool>(p.is_symm_kernel))},
        {"ksize_h", json::NumberInt::make(static_cast<int64_t>(p.ksize_h))},
        {"ksize_w", json::NumberInt::make(static_cast<int64_t>(p.ksize_w))},
        {"anchor_h", json::NumberInt::make(static_cast<int64_t>(p.anchor_h))},
        {"anchor_w", json::NumberInt::make(static_cast<int64_t>(p.anchor_w))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::LocalShare &p) {
    auto Mode2str = [](const param::LocalShare::Mode arg) -> std::string {
        switch (arg) {
            case param::LocalShare::Mode::CROSS_CORRELATION: return "CROSS_CORRELATION";
            case param::LocalShare::Mode::CONVOLUTION: return "CONVOLUTION";
            default: mgb_throw(MegBrainError, "Invalid param::LocalShare::Mode:%d", static_cast<int>(arg));
        }
    };
    auto Sparse2str = [](const param::LocalShare::Sparse arg) -> std::string {
        switch (arg) {
            case param::LocalShare::Sparse::DENSE: return "DENSE";
            case param::LocalShare::Sparse::GROUP: return "GROUP";
            default: mgb_throw(MegBrainError, "Invalid param::LocalShare::Sparse:%d", static_cast<int>(arg));
        }
    };
    auto Format2str = [](const param::LocalShare::Format arg) -> std::string {
        switch (arg) {
            case param::LocalShare::Format::NCHW: return "NCHW";
            case param::LocalShare::Format::NHWC: return "NHWC";
            case param::LocalShare::Format::NHWCD4: return "NHWCD4";
            case param::LocalShare::Format::NCHW4: return "NCHW4";
            case param::LocalShare::Format::NCHW8: return "NCHW8";
            case param::LocalShare::Format::NCHW32: return "NCHW32";
            case param::LocalShare::Format::NCHW88: return "NCHW88";
            case param::LocalShare::Format::NCHW44: return "NCHW44";
            case param::LocalShare::Format::NCHW44_DOT: return "NCHW44_DOT";
            case param::LocalShare::Format::NCHW_WINOGRAD: return "NCHW_WINOGRAD";
            case param::LocalShare::Format::NCHW88_WINOGRAD: return "NCHW88_WINOGRAD";
            case param::LocalShare::Format::NCHW44_WINOGRAD: return "NCHW44_WINOGRAD";
            case param::LocalShare::Format::CHWN4: return "CHWN4";
            default: mgb_throw(MegBrainError, "Invalid param::LocalShare::Format:%d", static_cast<int>(arg));
        }
    };
    auto ComputeMode2str = [](const param::LocalShare::ComputeMode arg) -> std::string {
        switch (arg) {
            case param::LocalShare::ComputeMode::DEFAULT: return "DEFAULT";
            case param::LocalShare::ComputeMode::FLOAT32: return "FLOAT32";
            default: mgb_throw(MegBrainError, "Invalid param::LocalShare::ComputeMode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"mode", json::String::make(Mode2str(p.mode))},
        {"pad_h", json::NumberInt::make(static_cast<int64_t>(p.pad_h))},
        {"pad_w", json::NumberInt::make(static_cast<int64_t>(p.pad_w))},
        {"stride_h", json::NumberInt::make(static_cast<int64_t>(p.stride_h))},
        {"stride_w", json::NumberInt::make(static_cast<int64_t>(p.stride_w))},
        {"dilate_h", json::NumberInt::make(static_cast<int64_t>(p.dilate_h))},
        {"dilate_w", json::NumberInt::make(static_cast<int64_t>(p.dilate_w))},
        {"spatial_groups_h", json::NumberInt::make(static_cast<int64_t>(p.spatial_groups_h))},
        {"spatial_groups_w", json::NumberInt::make(static_cast<int64_t>(p.spatial_groups_w))},
        {"sparse", json::String::make(Sparse2str(p.sparse))},
        {"format", json::String::make(Format2str(p.format))},
        {"computeMode", json::String::make(ComputeMode2str(p.computeMode))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::ROIAlign &p) {
    auto Mode2str = [](const param::ROIAlign::Mode arg) -> std::string {
        switch (arg) {
            case param::ROIAlign::Mode::MAX: return "MAX";
            case param::ROIAlign::Mode::AVERAGE: return "AVERAGE";
            default: mgb_throw(MegBrainError, "Invalid param::ROIAlign::Mode:%d", static_cast<int>(arg));
        }
    };
    auto Format2str = [](const param::ROIAlign::Format arg) -> std::string {
        switch (arg) {
            case param::ROIAlign::Format::NCHW: return "NCHW";
            case param::ROIAlign::Format::NHWC: return "NHWC";
            case param::ROIAlign::Format::NHWCD4: return "NHWCD4";
            case param::ROIAlign::Format::NCHW4: return "NCHW4";
            case param::ROIAlign::Format::NCHW8: return "NCHW8";
            case param::ROIAlign::Format::NCHW32: return "NCHW32";
            case param::ROIAlign::Format::NCHW88: return "NCHW88";
            case param::ROIAlign::Format::NCHW44: return "NCHW44";
            case param::ROIAlign::Format::NCHW44_DOT: return "NCHW44_DOT";
            case param::ROIAlign::Format::NCHW_WINOGRAD: return "NCHW_WINOGRAD";
            case param::ROIAlign::Format::NCHW88_WINOGRAD: return "NCHW88_WINOGRAD";
            case param::ROIAlign::Format::NCHW44_WINOGRAD: return "NCHW44_WINOGRAD";
            case param::ROIAlign::Format::CHWN4: return "CHWN4";
            default: mgb_throw(MegBrainError, "Invalid param::ROIAlign::Format:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"mode", json::String::make(Mode2str(p.mode))},
        {"format", json::String::make(Format2str(p.format))},
        {"spatial_scale", json::Number::make(static_cast<double>(p.spatial_scale))},
        {"offset", json::Number::make(static_cast<double>(p.offset))},
        {"pooled_height", json::NumberInt::make(static_cast<int64_t>(p.pooled_height))},
        {"pooled_width", json::NumberInt::make(static_cast<int64_t>(p.pooled_width))},
        {"sample_height", json::NumberInt::make(static_cast<int64_t>(p.sample_height))},
        {"sample_width", json::NumberInt::make(static_cast<int64_t>(p.sample_width))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::DeformablePSROIPooling &p) {
    return json::Object::make({
        {"no_trans", json::Bool::make(static_cast<bool>(p.no_trans))},
        {"spatial_scale", json::Number::make(static_cast<double>(p.spatial_scale))},
        {"trans_std", json::Number::make(static_cast<double>(p.trans_std))},
        {"pooled_h", json::NumberInt::make(static_cast<int64_t>(p.pooled_h))},
        {"pooled_w", json::NumberInt::make(static_cast<int64_t>(p.pooled_w))},
        {"part_size", json::NumberInt::make(static_cast<int64_t>(p.part_size))},
        {"sample_per_part", json::NumberInt::make(static_cast<int64_t>(p.sample_per_part))},
    });
}
template<>
std::shared_ptr<mgb::json::Value> opr_param_to_json(const param::BatchConvBias &p) {
    auto NonlineMode2str = [](const param::BatchConvBias::NonlineMode arg) -> std::string {
        switch (arg) {
            case param::BatchConvBias::NonlineMode::IDENTITY: return "IDENTITY";
            case param::BatchConvBias::NonlineMode::RELU: return "RELU";
            case param::BatchConvBias::NonlineMode::SIGMOID: return "SIGMOID";
            case param::BatchConvBias::NonlineMode::H_SWISH: return "H_SWISH";
            default: mgb_throw(MegBrainError, "Invalid param::BatchConvBias::NonlineMode:%d", static_cast<int>(arg));
        }
    };
    auto Mode2str = [](const param::BatchConvBias::Mode arg) -> std::string {
        switch (arg) {
            case param::BatchConvBias::Mode::CROSS_CORRELATION: return "CROSS_CORRELATION";
            case param::BatchConvBias::Mode::CONVOLUTION: return "CONVOLUTION";
            default: mgb_throw(MegBrainError, "Invalid param::BatchConvBias::Mode:%d", static_cast<int>(arg));
        }
    };
    auto Sparse2str = [](const param::BatchConvBias::Sparse arg) -> std::string {
        switch (arg) {
            case param::BatchConvBias::Sparse::DENSE: return "DENSE";
            case param::BatchConvBias::Sparse::GROUP: return "GROUP";
            default: mgb_throw(MegBrainError, "Invalid param::BatchConvBias::Sparse:%d", static_cast<int>(arg));
        }
    };
    auto Format2str = [](const param::BatchConvBias::Format arg) -> std::string {
        switch (arg) {
            case param::BatchConvBias::Format::NCHW: return "NCHW";
            case param::BatchConvBias::Format::NHWC: return "NHWC";
            case param::BatchConvBias::Format::NHWCD4: return "NHWCD4";
            case param::BatchConvBias::Format::NCHW4: return "NCHW4";
            case param::BatchConvBias::Format::NCHW8: return "NCHW8";
            case param::BatchConvBias::Format::NCHW32: return "NCHW32";
            case param::BatchConvBias::Format::NCHW88: return "NCHW88";
            case param::BatchConvBias::Format::NCHW44: return "NCHW44";
            case param::BatchConvBias::Format::NCHW44_DOT: return "NCHW44_DOT";
            case param::BatchConvBias::Format::NCHW_WINOGRAD: return "NCHW_WINOGRAD";
            case param::BatchConvBias::Format::NCHW88_WINOGRAD: return "NCHW88_WINOGRAD";
            case param::BatchConvBias::Format::NCHW44_WINOGRAD: return "NCHW44_WINOGRAD";
            case param::BatchConvBias::Format::CHWN4: return "CHWN4";
            default: mgb_throw(MegBrainError, "Invalid param::BatchConvBias::Format:%d", static_cast<int>(arg));
        }
    };
    auto ComputeMode2str = [](const param::BatchConvBias::ComputeMode arg) -> std::string {
        switch (arg) {
            case param::BatchConvBias::ComputeMode::DEFAULT: return "DEFAULT";
            case param::BatchConvBias::ComputeMode::FLOAT32: return "FLOAT32";
            default: mgb_throw(MegBrainError, "Invalid param::BatchConvBias::ComputeMode:%d", static_cast<int>(arg));
        }
    };
    return json::Object::make({
        {"nonlineMode", json::String::make(NonlineMode2str(p.nonlineMode))},
        {"mode", json::String::make(Mode2str(p.mode))},
        {"pad_h", json::NumberInt::make(static_cast<int64_t>(p.pad_h))},
        {"pad_w", json::NumberInt::make(static_cast<int64_t>(p.pad_w))},
        {"stride_h", json::NumberInt::make(static_cast<int64_t>(p.stride_h))},
        {"stride_w", json::NumberInt::make(static_cast<int64_t>(p.stride_w))},
        {"dilate_h", json::NumberInt::make(static_cast<int64_t>(p.dilate_h))},
        {"dilate_w", json::NumberInt::make(static_cast<int64_t>(p.dilate_w))},
        {"sparse", json::String::make(Sparse2str(p.sparse))},
        {"format", json::String::make(Format2str(p.format))},
        {"compute_mode", json::String::make(ComputeMode2str(p.compute_mode))},
    });
}
} // namespace opr
} // namespace mgb

// vim: syntax=cpp.doxygen
